[ { "title": "React - JSX 알아보기", "url": "/posts/understanding-jsx/", "categories": "Web, React", "tags": "web, frontend, reactjs, jsx", "date": "2022-03-09 22:00:00 +0900", "snippet": "요약근본적으로 JSX 파일은 React.createElement (component, props, … , children)에 대한 문법적 설탕을 제공하는 것 그 이상도 그 이하도 아니다.HTML&amp;lt;MyButton color=“blue” shadowSize={2}&amp;gt; Click Me&amp;lt;/MyButton&amp;gt;이 HTML파일을 JSX파일로 컴파일JSXReact.createElement( MyButton, {color: ‘blue’, shadowSize: 2}, ’Click Me’)HTML을 JSX로 컴파일하는 또다른 예시HTML&amp;lt;div className=“sidebar” /&amp;gt;JSXReact.createElement( ‘div’, {className: ‘sidebar’})React 엘리먼트 타입 지정JSX 형식 태그의 첫부분은 React Element의 타입을 결정한다.React가 반드시 Scope 내에 존재해야 한다React library도 JSX 코드와 같은 scope 안에 있어야 한다. React는 JavaScript 코드에선 직접적으로 사용되지는 않지만 JSX 태그로 사용할 수 있기 위해 반드시 import 해야 한다.import React from ‘react’;JSX 타입을 위한 점 표기법JSX 내에서도 점 표기법을 사용해서 React 컴포넌트를 참조한다. 이 방법은 하나의 모듈에서 복수의 React 컴포넌트들을 export 하는 경우에 편리하게 사용할 수 있다.import React from ‘react’;const MyComponents = { DatePicker: function DatePicker(props) { return &amp;lt;div&amp;gt;Imagine a {props.color} datepicker here.&amp;lt;/div&amp;gt;; }}function BlueDatePicker() { return &amp;lt;MyComponents.DatePicker color: “blue” /&amp;gt;}위 예시에선 MyComponents의 DatePicker를 점 표기법을 사용해서 호출한 것을 확인할 수 있다.사용자정의 컴포넌트는 반드시 대문자 시작 Element가 소문자로 시작하는 경우는 &amp;lt;div&amp;gt;, &amp;lt;span&amp;gt;과 같은 내장 컴포넌트들일 경우이다.=&amp;gt; 이는 ‘div’, ‘span’처럼 문자열형으로 React.createElement에 전달된다. Element가 대문자로 시작하는 경우는 &amp;lt;Foo /&amp;gt;와 같은 사용자 정의 컴포넌트이다.(사용자정의 컴포넌트란 JavaScript 파일 내에 사용자가 정의했거나, import한 컴포넌트를 말한다.)=&amp;gt; React.createElement(Foo)와 같은 형태로 컴파일 된다.import React from &#39;react&#39;;// 올바른 표기 방법이다. 아래는 사용자 정의 컴포넌트이므로 대문자로 시작한다.function Hello (props) { // 올바른 사용법이다. 아래 &amp;lt;div&amp;gt;태그는 유효한 HTML 태그이기 때문에 유효하다. return &amp;lt;div&amp;gt;Hello {props.toWhat}&amp;lt;/div&amp;gt;;}function HelloWorld() { // 올바른 사용법이다. React는 &amp;lt;Hello /&amp;gt;가 대문자로 시작하므로 사용자정의 컴포넌트로 인식한다. return &amp;lt;Hello toWhat=&quot;World&quot; /&amp;gt;;}실행 중 타입 선택하기React Element에 일반적인 표현식은 사용할 수 없다.import React from &#39;react&#39;;import { PhotoStory, VideoStory } from &#39;./stories&#39;;const components = { photo: PhotoStory, video: VideoStory,};function Story (props) { // 잘못된 표현이다. JSX 타입을 직접적이게 표현식으로 사용 불가하다. // return &amp;lt;components[props.storyType] story={props.story} /&amp;gt;; // 올바른 표현. 대문자로 시작하는 변수만 JSX타입으로 가능하다. const SpecificStory = components[props.storyType]; return &amp;lt;SpecificStory story={props.story} /&amp;gt;;}JSX 에서 props 사용하기1. JavaScript 표현식JavaScript 표현식을 { }(중괄호) 안에 넣어서 props 으로 사용한다.if 구문과 for loop 등은 JavaScript 표현식의 범위 안에 들어가지 않기 때문에 JSX 안에서 직접적으로는 사용할 수 없다. 따라서, 아래 코드처럼 바깥쪽에 간접적으로 사용해야 한다.function NumberDescriber (props) { let description; if (props.number % 2 === 0) { description = &amp;lt;strong&amp;gt;even&amp;lt;/strong&amp;gt;; } else { description = &amp;lt;i&amp;gt;odd&amp;lt;/i&amp;gt;; } return &amp;lt;div&amp;gt;{props.number} is an {description} number&amp;lt;/div&amp;gt;;}JavaScript 표현식의 범위그렇다면 JSX에서 props로 사용할 수 있다는 자바스크립트 표현식의 범위는 어디까지일까?먼저 표현식이란 무엇일까. 표현식(expression)은 값으로 평가될 수 있는 임의의 유효한 코드 단위 즉, 문(statement)이다.표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다는 것이다.이때의 값(value)이란, 표현식(expression)이 평가(evaluate)되어 생성 되어진 결과를 의미하는데 평가(evaluate)는 표현식을 해석해서 값을 생성하거나 참조하는 것을 나타낸다.결국, 값으로 평가될 수 있는 모든 statement들은 표현식이라고 볼 수 있다.// 리터럴 표현식0721&#39;Hello World!&#39;// 식별자 표현식 (선언은 이미 존재하는 경우)sumperson.agearr[0]// 연산자 표현식20 + 30sum = 21sum !== 20// 함수/메소드 호출 표현식 (선언은 이미 존재하는 경우)person.getAge()square()2. 문자열 리터럴문자열 리터럴을 props로 넘겨서 줄 수 있다. 아래의 두 JSX 표현은 동일한 결과를 도출한다.&amp;lt;MyComponent message=&quot;Hello, World!&quot; /&amp;gt; // 문자열 리터럴로&amp;lt;MyComponent message={&#39;Hello, World!&#39;} /&amp;gt; // JavaScript 표현식으로3. props의 default는 “True”props에 어떠한 값도 할당하지 않는 경우, default 값은 true이다. 아래의 두 JSX 표현은 동일하다.&amp;lt;MyTextBox autocomplete /&amp;gt;&amp;lt;MyTextBox autocomplete={true} /&amp;gt;React 공식문서에서는 props에 값을 전달하지 않는 것을 권장하지 않는다.이는 JavaScript의 객체 초기자와 헷갈릴 수도 있기 때문이라고 한다.Ex) JSX에서 {foo}는 {foo: true}가 아닌 {foo: foo}로 동작한다.JSX에서 자식(children) 다루기문자열 리터럴여는 태그와 닫는 태그 사이에 문자열 리터럴을 넣을 수 있고, 이 때 props.children은 그 문자열이 된다.&amp;lt;MyComponent&amp;gt;Hello World!&amp;lt;/MyComponent&amp;gt;여기서 MyComponent의 props.children은 Hello World! 이다.일반적으로 HTML을 쓰는 방식으로 JSX를 그대로 쓸 수 있다.JSXJSX element 역시 자식으로 사용할 수 있다. 이는 중첩된 Component를 보여줄 때 유용하다.&amp;lt;MyContainer&amp;gt; &amp;lt;MyFirstChildren /&amp;gt; &amp;lt;MySecondChildren /&amp;gt;&amp;lt;/MyContainer&amp;gt;다양한 타입의 자식들을 혼합해서 사용할 수도 있기 때문에 문자열 리터럴을 JSX 자식과 함께 사용할 수 있다.React Component에서는 element로 이루어진 배열을 return 할 수도 있다.render() { // 리스트 item들을 굳이 추가적인 element로 감쌀 필요 없다 return [ // jsx에서 리스트 사용시 반드시 key 지정하기 &amp;lt;li key=&quot;A&quot;&amp;gt;First item&amp;lt;/li&amp;gt;, &amp;lt;li key=&quot;B&quot;&amp;gt;Second item&amp;lt;/li&amp;gt;, &amp;lt;li key=&quot;C&quot;&amp;gt;Third item&amp;lt;/li&amp;gt;, ];}JavaScript 표현식{ }(중괄호)를 통해서 JavaScript 표현식 역시 자식으로 사용할 수 있다. 아래 두 코드들은 동일하다.&amp;lt;MyComponent&amp;gt;foo&amp;lt;/MyComponent&amp;gt;&amp;lt;MyComponent&amp;gt;{&#39;foo&#39;}&amp;lt;/MyComponent&amp;gt;JavaScript 표현식을 자식으로 사용하는 방법은 임의 길이의 JSX 표현식의 배열을 렌더링할 때 유용하게 사용된다. 아래 코드는 HTML 배열(&amp;lt;li&amp;gt;)로 렌더된다.function Item(props) { return &amp;lt;li&amp;gt;{props.message}&amp;lt;/li&amp;gt;;}function TodoList() { const todos = [&#39;finish doc&#39;, &#39;submit pr&#39;, &#39;nag dan to review&#39;]; return ( &amp;lt;ul&amp;gt; {todos.map((message) =&amp;gt; &amp;lt;Item key={message} message={message} /&amp;gt;)} &amp;lt;/ul&amp;gt; );}함수(Function)함수를 자식으로 사용할 수 있다.props.children은 다른 props들처럼 React가 렌더링 할 수 있는 데이터의 형태 이외에도 어떤 형태의 데이터를 넘겨 받을 수 있다. 사용자정의 컴포넌트가 있다면 props.children을 통해서 콜백 받을 수 있다.// 자식 콜백인 numTimes를 호출하여 반복되는 컴포넌트를 생성합니다.function Repeat(props) { let items = []; for (let i = 0; i &amp;lt; props.numTimes; i++) { items.push(props.children(i)); } return &amp;lt;div&amp;gt;{items}&amp;lt;/div&amp;gt;;}function ListOfTenThings() { return ( &amp;lt;Repeat numTimes={10}&amp;gt; {(index) =&amp;gt; &amp;lt;div key={index}&amp;gt;This is item {index} in the list&amp;lt;/div&amp;gt;} &amp;lt;/Repeat&amp;gt; );}이러한 사용법이 일반적이다고는 할 수 없지만, JSX 기능의 확장성을 보여주는 부분이다.boolean, null, undefined는 무시true, false, null, undefined는 모두 유효한 자식이나, 단지 렌더링 되지 않는다.이는 React element를 조건부 렌더링 시 유용하게 사용된다. 아래 코드는 showHeader가 true일 때 동일하게 &amp;lt;Header /&amp;gt;를 렌더한다.&amp;lt;div&amp;gt; {showHeader &amp;amp;&amp;amp; &amp;lt;Header /&amp;gt;} &amp;lt;Content /&amp;gt;&amp;lt;/div&amp;gt;반대로 true, false, null, undefined과 같은 값들을 출력하고 싶다면 먼저 문자열로 전환해야 한다. (String(thing))&amp;lt;div&amp;gt; My JavaScript variable is {String(myVariable)}.&amp;lt;/div&amp;gt;React를 제대로 공부하려면 리액트 웹사이트 들어가서 공식 문서를 직접 읽어보면서 이해하는 것을 적극 추천한다.출처: React 공식 문서 (https://ko.reactjs.org/docs/jsx-in-depth.html)" }, { "title": "Data Structure (#1) Hash Table", "url": "/posts/hashTable/", "categories": "CS, Data Structure", "tags": "data structure, algorithm, hashtable, array, list, map, chaining", "date": "2022-02-27 21:40:00 +0900", "snippet": "해시 테이블해시테이블은 해시 함수를 활용해서 키를 해시값으로 매핑하고, 이 해시값을 색인(인덱스) 또는 주소 삼아 데이터를 key와 함께 저장하는 자료구조를 뜻한다.➡️ [key:value]로 데이터를 저장하는 자료구조그리고 해시란, 키와 값이 한 쌍으로 구성된 데이터를 가리킨다.출처: 위키백과_해시테이블해시 테이블의 구성해시테이블은 키(key), 값(value), 해시함수(hash function), 해시(hash), 데이터가 저장되는 곳(bucket, slot)으로 구성되어 있다.처음에 해시 테이블에 대해 들었을때 총체적 난국이었다. 해시는 뭐고, 해시 함수는 뭐고, 이게 왜 효율적인 자료구조라는거야? cs는 대부분 영어를 해석해야 되기 때문에 직관적으로 이해하기는 어려운 것 같다. 그래서 하나하나 차근차근 알아가야 한다. What is Hash Function?해시함수는 key를 고정된 크기의 hash로 변경해주는 함수이다. 이 과정을 hashing이라고 부른다. key를 hash function에 매개변수로 넣어서 return 값으로 나오는 값이 hash라고 생각하면 된다. 그리고 이 hash가 저장인덱스가 된다고 생각하면 될 것 같다. What is hash?hash는 색인(인덱스)라고 편하게 생각하면 된다. function hashStringToInt(str, tableSize) {// string 키값을 받아서 int형 인덱스로 전환해주는 함수 let hash = 17; // 소수를 값으로 지정함으로서 장점은 키를 잘 분산시킬 수 있다. for (let i=0; i&amp;lt;str.length; i++) { hash = (7 * hash * str.charCodeAt(i)) % tableSize; // charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수를 반환한다. } return hash; // hash(idx)를 리턴해주는 형태} 해시함수이번에 사용한 해시함수 방법은 일종의 Division Method와 각 key의 문자열을 ASCII코드로 바꿔 계산하는 방법이다.Division Method: 나눗셈을 이용하는 방법으로 입력값을 테이블의 크기로 나누어 계산한다.( 주소 = 입력값 % 테이블의 크기) 테이블의 크기를 소수로 정하고 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려져 있다.따라서, 해시테이블은 기본적으로 key 값과 해당 key에 대응하는 value로 구성되고, 중복을 허용하지 않는 경우에 특정 key값에 대한 값을 찾는 시간 복잡도는 O(1)로 알려져 있다. 최악의 경우엔 모든 요소를 순회해야 하므로 시간 복잡도는 O(n)이 될 것이다.해시 충돌해시 충돌이란?만약에 “firstName”, “lastName” 이라는 두 가지 key가 있다고 해보자. 이 때, “firstName”, “lastName”을 hash function을 통해서 각각 hash를 얻었는데 이 hash가 둘다 똑같이 6이 나왔다고 해보자. 이렇게 된다면 서로 충돌이 일어나서 올바른 값을 불러오지 못하는데 이러한 현상을 해시 충돌, Hash Collision이라고 한다.해시 충돌 해결법해시 충돌 해결법에는 크게 2가지가 있다. 연결법(Chaining) 개방 주소법(Open Addressing)여기서는 Chaining 방법을 사용해서 해시 충돌을 해결해볼 것이다.// Collapse(충돌)가 발생할 때 어떻게 대처해야 하는가set_item = (key, value) =&amp;gt; { this.numItems++; const loadFactor = this.numItems / this.table.length; if (loadFactor &amp;gt; .8) { //resize this.resize(); } const idx = hashStringToInt(key, this.table.length); if (this.table[idx]) { // this.table[idx]에 이미 값이 존재할 때 this.table[idx].push([key, value]); console.log(this.table[idx]) } else { this.table[idx] = [[key, value]]; }};get_item = (key) =&amp;gt; { const idx = hashStringToInt(key, this.table.length); if (!this.table[idx]) { // Simple Error Checking return null; } console.log(this.table[idx]) return this.table[idx].find(x =&amp;gt; x[0] === key)[1]; // find() 메서드는 주어진 판별 함수를 만족하는 첫 요소 값 반환. 그런 요소가 없다면 undefined 반환. // };Chaining기존 해시테이블 구조로는, 해시 주소 하나에 하나의 슬롯이 존재해 이미 점유된 슬롯에 중복되어서는 안됐다. 하지만, chaining 기법은 점유된 슬롯을 패스하는 것이 아닌, 점유된 슬롯에 자료를 추가하는 방식으로, Linked List와 유사한 구조로 구현된다.해시 주소 하나에 리스트(배열)가 하나씩 배정된다면 리스트에 슬롯(일종의 노드)을 연결하는 방식으로 다른 주소로 이동하는 것을 없애는 것이다.위에 내가 첨부한 코드를 보면set_item = (key, value) =&amp;gt; {...if (this.table[idx]) { // this.table[idx]에 이미 값이 존재할 때 this.table[idx].push([key, value]); console.log(this.table[idx])}...};한 해시 주소에 이미 값이 존재할 때 그 주소에 [key, value] 배열을 push함으로써 한 주소에 두 가지 슬롯이 존재하게 된다.get_item = (key) =&amp;gt; {... if (!this.table[idx]) { // Simple Error Checking return null; } console.log(this.table[idx]) return this.table[idx].find(x =&amp;gt; x[0] === key)[1]; // find() 메서드는 주어진 판별 함수를 만족하는 첫 요소 값 반환. 그런 요소가 없다면 undefined 반환....};이렇게 get_item 메소드에서 리턴할 때 조건을 만족하는 요소를 find()를 통해서 반환하게 된다.해시 테이블 언제 사용하는가1:1(key : value)로 구성되어 Time Complexity가 최소 O(1), 최대 O(n)인 점을 활용하는 방안 방대한 양을 검색하고, 조회해봐야 하는 경우 ➡️ 해시테이블로 조회하기 (Ex. 주소록) 중복된 항목 방지해야 하는 경우 ➡️ 해시테이블을 이용 (Ex. 누가 이미 응모했는지 확인하는 경우) 해시테이블을 캐시로 사용하기 ➡️ (Ex. 캐시(해시테이블의 버켓)에 존재하는 페이지 기록 호출하는 경우)해시 테이블 예시 공부 코드function hashStringToInt(str, tableSize) { let hash = 17; // 소수를 값으로 지정함으로서 장점은 키를 잘 분산시킬 수 있다. for (let i=0; i&amp;lt;str.length; i++) { hash = (7 * hash * str.charCodeAt(i)) % tableSize; // charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수를 반환한다. } return hash;}class HashTable { table = new Array(3); numItems = 0; resize = () =&amp;gt; { const newTable = new Array(this.table.length * 2); this.table.forEach(item =&amp;gt; { // forEach() 메서드는 주어진 함수를 배열 요소 각각에 대해 실행합니다. if (item) { item.forEach(([key, value]) =&amp;gt; { const idx = hashStringToInt(key, newTable.length); if (newTable[idx]) { newTable[idx].push([key, value]); } else { newTable[idx] = [[key, value]]; } }); } }); this.table = newTable; } // Collapse(충돌)가 발생할 때 어떻게 대처해야 하는가 set_item = (key, value) =&amp;gt; { this.numItems++; const loadFactor = this.numItems / this.table.length; if (loadFactor &amp;gt; .8) { //resize this.resize(); } const idx = hashStringToInt(key, this.table.length); if (this.table[idx]) { // this.table[idx]에 이미 값이 존재할 때 this.table[idx].push([key, value]); console.log(this.table[idx]) } else { this.table[idx] = [[key, value]]; } }; get_item = (key) =&amp;gt; { const idx = hashStringToInt(key, this.table.length); if (!this.table[idx]) { // Simple Error Checking return null; } console.log(this.table[idx]) return this.table[idx].find(x =&amp;gt; x[0] === key)[1]; // find() 메서드는 주어진 판별 함수를 만족하는 첫 요소 값 반환. 그런 요소가 없다면 undefined 반환. // };}const myTable = new HashTable();myTable.set_item(&quot;firstName&quot;, &quot;bob&quot;);console.log(myTable.table.length);myTable.set_item(&quot;lastName&quot;, &quot;Tim&quot;);myTable.set_item(&quot;age&quot;, 23);console.log(myTable.table.length);myTable.set_item(&quot;birthday&quot;, &quot;2000/07/21&quot;);console.log(myTable.table);console.log(myTable.get_item(&quot;firstName&quot;));console.log(myTable.get_item(&quot;lastName&quot;));console.log(myTable.get_item(&quot;age&quot;));console.log(myTable.get_item(&quot;birthday&quot;));// 출처: Ben Award 유튜브 (https://youtu.be/UOxTMOCTEZk)깃헙 주소https://github.com/k-hyeongi/Algorithm/blob/main/HashTable출처: Ben Award 유튜브 (https://youtu.be/UOxTMOCTEZk)" }, { "title": "React 웹앱 구현하기 (생활코딩)", "url": "/posts/react-app-dailylife/", "categories": "Web, React", "tags": "html, css, javascript, reactjs, frontend, 생활코딩", "date": "2022-02-20 18:00:00 +0900", "snippet": "npm 그리고 npxnpx 명령어를 사용해서 패키지를 설치할 때도 있고, npm 명령어를 사용해서 할 때도 있다. 둘 사이의 차이점이 모호할 때가 종종 있는데 무슨 차이가 있는지 알아볼 필요가 있다.깊게 들어가보면 많은 차이가 있겠지만, 중점적으로 알면 좋을 것들만 알아보자.npx는 새로운 패키지 관리 모듈은 아니다. 기존 자바스크립트 패키지 관리 모듈인 npm(Node Package Module)의 5.2.0 버전부터 npm에 추가가 되었는데, 이는 npm의 단점을 보완해 npm을 더 편히 사용하게 해주는 도구임을 의미한다.npx란npx는 npm에 올라가있는 패키지를 쉽게 설치하고 관리할 수 있게 도와주는 CLI 도구이다. npm을 통해 설치할 수 있는 모든 종류의 node.js기반 파일들을 간단하게 설치 및 실행할 수 있게 도와준다.기존 npm의 단점으로는 굉장히 변화가 심한 자바스크립트 생태계에서 전역이나 로컬에서 설치해 관리하게 되면 관리가 되게 쉽지 않다는 점이 있었다.이때 이 문제를 해결하는 도구가 npx이다. npx는 일회성으로 원하는 패키지를 npm 레지에 접근해서 설치하고 실행시키기 때문에 자신이 따로 패키지를 설치하고 업데이트하는 과정이 없이도 npm 레지에 올라가있는 최신 버전을 실행시키면 되는 간편한 도구인 것이다.간단하게 요약하자면…npm: 프로그램 및 패키지를 설치하는 프로그램 인 것이고,npx: 프로그램을 임시로 설치해서 한번만 실행시키고 지우는 도구인 것이다.이는 로컬 컴퓨터에서 공간을 낭비하지 않고, 가장 최신의 프로그램을 사용할 수 있다는 장점이 있다.npm install -g create-react-app(npm을 이용한 리액트 설치)npx create-react-app 폴더이름(npx를 이용한 리액트 설치)npx 사용 이유npm 이라는 무거운 패키지 안에는 자주 사용하지 않는 파일들이 로컬에 남는 것npx는 최신 버전에 해당하는 패키지를 설치 및 실행 시 이전 버전 패키지를 제거 해줌npm run start? build? 개발하는 중: npm run start➡️ localhost로 개발중인 리액트 웹앱을 실행해줌으로써 작업중인 내용을 테스트하고 확인하기 좋다. 그러나 npm run start의 단점은 웹의 용량이 상당하다는 점이다. (Default 기본 페이지의 크기가 약 2MB) 웹앱 완성 이후: npm run build➡️ 따라서 개발이 끝나고 완성한 후엔 npm run build를 통해서 build 폴더를 만들어주고, 그 build 폴더를 배포한다. 빌드된 웹의 용량은 상당히 개선된다. (Default 기본 페이지의 크기가 약 200KB)React 기초 내용index.html, index.js맨 처음에 create-react-app을 통해서 리액트 프로젝트를 생성하게 되면 node_modules, public, src 폴더와 여러 json 파일들이 생성이 된다. 이 때 public 폴더에 index.html 파일이 있는 걸 볼 수 있을 것이다. 이 index.html 파일은 일종의 React Template으로 이 파일만 인터넷에서 열게 된다면 빈 화면만 나타나게 된다.index.html에서 중요한 부분은 body태그의 id=”root” 부분이다.&amp;lt;body&amp;gt; &amp;lt;noscript&amp;gt;You need to enable JavaScript to run this app.&amp;lt;/noscript&amp;gt; &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- This HTML file is a template. If you open it directly in the browser, you will see an empty page. You can add webfonts, meta tags, or analytics to this file. The build step will place the bundled scripts into the &amp;lt;body&amp;gt; tag. To begin the development, run `npm start` or `yarn start`. To create a production bundle, use `npm run build` or `yarn build`. --&amp;gt;&amp;lt;/body&amp;gt;저 부분에 React 프레임워크를 통해서 만들어진 태그들이 들어가 있다.src 폴더 안의 index.js 파일에 보면ReactDOM.render( &amp;lt;React.StrictMode&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/React.StrictMode&amp;gt;, document.getElementById(&#39;root&#39;));ReactDOM이 render되는 부분이 있는데 여기서 index.html의 root 영역에 개입하는 것이다.ReactDOM.render(element, container[, callback])React 엘리먼트를 container DOM에 렌더링하고 컴포넌트에 대한 참조를 반환합니다(무상태 컴포넌트는 null을 반환합니다).React 엘리먼트가 이전에 container 내부에 렌더링 되었다면 해당 엘리먼트는 업데이트하고 최신의 React 엘리먼트를 반영하는 데 필요한 DOM만 변경합니다.추가적인 콜백이 제공된다면 컴포넌트가 렌더링되거나 업데이트된 후 실행됩니다.출처: 리액트 공식 사이트App.js따라서 실제로 초기 웹앱을 구동했을 때 보여지는 화면은 App.js의 코드들인 것이다.리액트 초기설정 화면App.js의 이 부분이 보여진다.function App() { return ( &amp;lt;div className=&quot;App&quot;&amp;gt; &amp;lt;header className=&quot;App-header&quot;&amp;gt; &amp;lt;img src={logo} className=&quot;App-logo&quot; alt=&quot;logo&quot; /&amp;gt; &amp;lt;p&amp;gt; Edit &amp;lt;code&amp;gt;src/App.js&amp;lt;/code&amp;gt; and save to reload. &amp;lt;/p&amp;gt; &amp;lt;a className=&quot;App-link&quot; href=&quot;https://reactjs.org&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; &amp;gt; Learn React &amp;lt;/a&amp;gt; &amp;lt;/header&amp;gt; &amp;lt;/div&amp;gt; );}따라서 index.html 내 보여지는 부분을 수정하고 싶을 땐 App.js 내의&amp;lt;div className=&quot;App&quot;&amp;gt; ...&amp;lt;/div&amp;gt;이 부분을 수정해주면 된다.Componentimport React, { Component } from &#39;react&#39;; // 필수class App extends Component { render() { return ( &amp;lt;div className=&quot;App&quot;&amp;gt; ... &amp;lt;/div&amp;gt; ); }}export default App; // 필수위 코드는 React의 Component 구조이다. class 안에 소속된 함수는 function으로 시작하는 않고 생략해도 된다. class는 반드시 render 메소드를 실행하고, Component를 생성할 때 반드시 하나의 최상위 태그로 시작해야 한다.이 구조가 모든 리액트 코딩의 근간이 된다.여기서 한 가지 신기했던 점은 위 코드들은 엄밀히 말하면 자바스크립트 코드가 아니다. 유사 자바스크립트 코드이고, 그렇기 때문에 위 코드를 크롬 콘솔에서 실행해보면 에러가 발생하는 것을 볼 수 있을 거다. 리액트에서 유사 자바스크립트 코드를 사용하는 이유는 무엇일까?페이스북에서 리액트를 개발할 때 자바스크립트에서 HTML 코드들을 사용하기 까다로워서 직접 JSX 형태를 개발해서 이 jsx파일을 리액트(create-react-app)를 통해서 js파일로 컨버팅 해준 것이다.리액트에서 Component의 생성은 정리정돈하는 것 정도로 생각하면 될 것 같다.props &amp;amp; state처음에 props와 state에 대해서 들었을 때 이 둘의 차이에 대해서 되게 애매하게 느껴졌고, 거기서 거기라고 생각해서 개념 정리가 잘 안 됐던 것 같다. 그래서, 따로 props와 state에 대해서 포스팅할 예정이다. 일단 이 포스트에서는 크게 짚고 넘어가진 않겠다.state를 쓰기 위해서는 state를 쓸 class 안에 constructor(props) { super(props); this.state = { subject: { title: &#39;WEB&#39;, sub: &#39;World Wide Web!! 🤪&#39;, } } }super(props)를 포함하는 constructor(props)가 필요하다.App이 내부적으로 사용할 요소들은 state를 사용해서 사용하지만index.js에서 바라볼때는 state를 사용하는지 모르게 하는 코드가 좋은 코드keyKey는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 도와준다.Key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다.예시로 TOC.js 파일을 들 수 있다.import React, { Component } from &#39;react&#39;class TOC extends Component { ... render() { console.log(&quot;TOC is rendered...&quot;); let lists = []; let data = this.props.data; let i = 0; while(i &amp;lt; data.length) { lists.push( &amp;lt;li key={data[i].id}&amp;gt; // 이 부분이다. &amp;lt;a href={&quot;/content/&quot; + data[i].id} data-id = {data[i].id} onClick={function(e) { e.preventDefault(); this.props.onChangePage(e.target.dataset.id); }.bind(this)} &amp;gt; {data[i].title} &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt;); i += 1; } ... }}export default TOC;위 코드에서 lists 배열 내부의 &amp;lt;li&amp;gt; 태그에 key를 지정한 것처럼 사용할 수 있다.그리고 위 코드에서 보이는 것과 같이 Key를 선택하는 가장 좋은 방법은 리스트의 다른 항목들 사이에서 해당 항목을 고유하게 식별할 수 있는 문자열을 사용하는 것이다. 대부분의 경우 데이터의 ID를 key로 사용한다.이벤트 생성anchor를 클릭 시에 이벤트를 생성하게 할 것이다.예시로 위의 TOC.js와 아래 App.js 코드의 일부를 봐보자. render() { // class 안에 소속된 함수는 function을 생략한다. return ( // 하위 컴포넌트들 &amp;lt;div className=&quot;App&quot;&amp;gt; ... &amp;lt;TOC onChangePage={function(id) { this.setState({ mode: &#39;read&#39;, selected_content_id: Number(id), }) }.bind(this)} data={this.state.contents}&amp;gt; &amp;lt;/TOC&amp;gt; ... &amp;lt;/div&amp;gt; ); }JavaScript에서는 이벤트 처리시 문법이 onclick=&quot;&quot; 이지만, React는 유사 JavaScript이므로 onClick={}을 사용한다.React에서는 onClick={}으로 이벤트를 처리하게 되면, 그 함수가 호출될 때, 그 함수의 첫째 매개변수 값으로 Event(e)라고 하는 객체가 주입되기로 약속되어 있다. (이벤트를 우리가 핸들링할 수 있도록 제공되는 것)이 e를 활용해서 많은 것을 할 수 있다.추가로 TOC.js 코드 중에onClick={function(e) { e.preventDefault(); // 이 것. this.props.onChangePage(e.target.dataset.id);}.bind(this)}e.preventDefault()라는 메소드를 실행시키는 것을 볼 수 있는데 이 메소드는 e가 가리키는 이벤트가 발생한 태그의 기본적인 동작을 못하게 만드는 녀석이라고 보면 된다.그리고 추가로 위에 TOC.js에서 볼 수 있는 것처럼 bind(this) 메소드를 이벤트 처리 함수 뒤에 실행해줘야 한다. bind(this) 메소드를 실행해주지 않으면 이벤트를 실행했을 때 this가 누구를 가리키는지 찾을 수 없어서 에러가 발생하기 때문이다.bind() 메소드 이해하기console.log()로 찍어서 확인해보면 render() 함수에서의 this는 class 자체를 가리킨다.그러나 onClick={} 이벤트 처리 중의 this는 undefined가 뜨는 것을 확인할 수 있다.왜 그런 것일까?JavaScript에서는 클래스 메서드는 기본적으로 바인딩되어 있지 않다.onChangePage를 바인딩 하지 않고 onClick에 전달하였다면, 함수가 실제 호출될 때 this는 undefined된다.이는 React만의 특수한 동작이 아니며, JavaScript에서 함수가 작동하는 방식의 일부이다.일반적으로 onClick={this.handleClick} 과 같이 뒤에 ()를 사용하지 않고 메서드를 참조할 경우,해당 메서드를 바인딩 해야한다.마치며일단은 대충 여기까지 정리하는 것으로 하고, 다음 포스팅에서는 생활코딩에서 실습한 React로 하는 CRUD (Create, Read, Update, Delete)를 정리해보도록 하겠다." }, { "title": "JavaScript and Node.js", "url": "/posts/js-and-nodejs/", "categories": "Web, JavaScript", "tags": "javascript, nodejs, frontend", "date": "2022-02-13 00:30:00 +0900", "snippet": "프로그래밍 언어란 무엇인가 프로그래밍 언어는 말 그대로 언어의 일종이다. 내가 영어라는 언어를 배우는 이유가 미국인과 대화하고 싶어서 인 것처럼 컴퓨터와 대화를 하고 싶어서 배우는 게 프로그래밍 언어이다. 즉, 사람과 컴퓨터가 서로 의사소통을 할 수 있게 해주는 수단이자 도구인 것이다.Q. 왜 프로그래밍 언어는 여러 개일까 그건 나와 같이 개발을 배우는 학부생의 입장에서는 별로 중요하지 않다. 간략하게 기업들은 본인들이 컨트롤할 수 없는 외부의 언어보다 본인들이 컨트롤할 수 있는 언어를 선호한다.결론은 내가 만들고 싶은 제품(Ex. ios, android)을 서비스하는 플랫폼(Ex. apple, google)이 권장하는 프로그래밍 언어를 배우면 된다.JavaScript란? javascript는 일반적인 정의로는 정적인 HTML페이지를 동적으로 움직이게 만들어주기 위해서 만들어진 프로그래밍 언어이다.그러나 js는 순수하게 언어의 관점에서는 좋지 않은데 왜 자바스크립트는 좋은 언어가 아닐까?JavaScript가 좋은 언어가 아닌 이유! 더하기(+)와 빼기(-) 연산의 동작 방식숫자를 더하기(+) -&amp;gt; 덧셈 (13 + 3 = 16)문자를 더하기(+) -&amp;gt; 문자열 연결 (“13” + “3” = “133”)숫자를 빼기(-) -&amp;gt; 뺄셈 (13 - 3 = 10)문자를 빼기(-) -&amp;gt; 뺄셈 (“13” - “3” = 10) ???? == 연산자의 동작 방식1 == 1 -&amp;gt; true1 == “1” -&amp;gt; truetrue == true -&amp;gt; truetrue == “true” -&amp;gt; false ????0 == [] -&amp;gt; true“0” == [] -&amp;gt; false0 == [0] -&amp;gt; true“0” == [“0”] -&amp;gt; true ???? 따라서 자바스크립트에서는 웬만하면 등호 세개(===)로 비교해야 한다. 이렇게 비교하면 거의 다 맞게 작동하는 걸 볼 수 있다.자바스크립트는 단 열흘만에 급조하여 완성된 프로그래밍 언어기 때문에 프로그래밍 완성도의 측면에서 그렇게 좋은 언어라고 볼 수 없겠다.Q1. JavaScript는 Java와 어떤 관련이 있는가 아무 관련이 없다. 자바의 인기에 편승하려고 자바스크립트라는 이름을 채택했다고 한다.Q2. JavaScript를 안 쓰고 HTML과 CSS 만으로 웹 프론트엔드를 만들 수 있는가 가능하고 권장할 때도 있다. 비개발자들과 웹사이트를 만들고 유지보수 시 자바스크립트는 사용하기에 적합하지 않다. 자바스크립트는 HTML, CSS와는 다르게 비개발자들이 이해하고 수정하기 어렵기 떄문에 개발자들만 고생한다.Node.js란? 크롬 V8 엔진을 기반으로 하는 JavaScript 런타임초심자들은 이해하기 어려운 개념이기 때문에 JavaScript로 백엔드, 즉 서버를 만들 수 있는 툴 정도로 이해하면 된다.Node.js의 성공 이유 프론트엔드 엔지니어들의 지지가 매우 높았다. Node.js의 공식 언어가 JavaScript였기 때문이다.Node.js의 장점 Django나 Spring과 비교해서 왜 Node.js를 쓸까 -&amp;gt; JavaScript를 사용해서웹 프레임워크의 최신 트렌드를 전부 받아들이고 빨리 적용하면서 컴파일러 언어인 자바에 비해 코딩하기 더 쉽고 훨씬 대중적이며, php보다는 잘 만든 언어이고 JavaScript를 도입했다는 점.참고한 영상데이터 유치원 채널의 알쓸코잡 재생목록https://youtube.com/playlist?list=PLOTd4L3rH1qXZViF3k6n7BTfyhrJSvfTK" }, { "title": "(#2) javascript 복습하기 (함수 ~ 배열)", "url": "/posts/js-review-2/", "categories": "Web, JavaScript", "tags": "node.js, javascript", "date": "2022-02-10 14:49:30 +0900", "snippet": "서론앞서 포스팅했던 자바스크립트 자료형부터 연산자까지 복습한 것에 이어서 나머지 자바스크립트 기초적인 내용들을 복습해보고자 한다.함수전역변수 &amp;amp; 지역변수let msg = &quot;welcome&quot;; // 전역변수console.log(msg); // welcomefunction sayHello(name) { let msg = &quot;hello&quot;; // 지역변수 console.log(msg + &quot;, &quot; + name);}sayHello(&#39;Justin&#39;); // hello, Justinconsole.log(msg); // welcome 전역변수와 지역변수는 서로에게서 간섭을 받지 않는다. 그러나 전체 서비스에서 공통으로 사용되는 변수를 제외하고는 지역변수를 사용하는 습관을 갖자 전역변수가 많아질수록 관리가 힘들어지므로 함수에 특화된 지역변수를 애용하자// default values function sayHello(name = &quot;friend&quot;) { console.log(`Hello, ${name}!!`);}sayHello(); // Hello, friend!!sayHello(&quot;justin&quot;); // Hello, justin!!// return문 관련function showErr() { // return값이 없는 함수 alert(&quot;에러가 발생했습니다.&quot;);}const result = showErr();console.log(result); // undefined// return 값이 없는 함수라도 항상 반환하는 값이 존재함!함수 팁 한 함수에서는 한 작업만 수행하기 읽기 쉽게, 어떤 동작을 수행하는 지 잘 네이밍하기함수 선언문 vs 함수 표현문// 함수 선언문 (함수를 선언하는 일반적인 방법)function sayHello() { console.log(&quot;Hello&quot;);}// 함수 표현문let sayHello = function() { console.log(&quot;Hello&quot;);}함수 선언문과 함수 표현문은 작성하는 문법 외에 또 어떤 차이가 있는 걸까?👉 호출할 수 있는 타이밍에 있다. 함수 선언문: 언제 어디서든 호출 가능sayHello(); // 에러 없이 실행된다. 어째서 와이??function sayHello() { ~~~~}자바스크립트 내부 알고리즘에 의해 실행된다. (Hoisting 호이스팅)👉 자바스크립트 실행 전 초기화 단계에서 코드의 모든 함수 선언문을 찾아서 생성해둔다고 한다. 이로 인해서 우리 눈에는 함수의 선언이 함수 호출보다 더 늦게 될거 같아보이지만 실제로는 함수의 선언 이후 호출되게 되는 것이다.함수 표현문: 코드에 도달하면 생성 👉 따라서 함수 표현문은 항상 함수를 선언하고 난 이후에 호출할 수 있다.화살표 함수let sayHello = (name) =&amp;gt; { console.log(&quot;Hello, &quot; + name);}난 솔직히 화살표 함수가 되게 어색한데 ES6 이후로 활발하게 사용된다고 하니 익숙해지도록 노력해야 겠다.객체// 객체의 기본 구조const superman = { // key: value name: &#39;Clark&#39;, age: 33, university: &#39;Handong&#39;, // method: 개체 프로퍼티로 할당된 함수 fly: function() { console.log(&quot;I can fly&quot;); } fly() { console.log(&quot;I can fly&quot;); } // 서로 동일한 메소드로 인식됨. sayHello: function() { console.log(`Hello, I&#39;m ${this.name}`); // superman.name이라고 쓰지 않음 }}객체 내 method에서 this 사용 시 주의사항👉 method를 화살표 함수로 선언했다면 동작이 매우 달라짐.화살표 함수는 일반 함수들과는 달리 자신의 this를 가지지 않으므로 화살표 함수 내부에서 this 사용시 함수 내에서가 아닌 외부에서 값을 가져오게 됨.// 접근superman.name; // Clarksuperman[&#39;age&#39;]; // 33// 추가superman.home = &#39;Seoul&#39;;superman[&#39;gender&#39;] = &#39;male&#39;;// 삭제delete superman.gender;// 단축 프로퍼티const name = &#39;Clark&#39;;const age = 33;const superman = { name, // name : name age, // age : age university: &#39;Handong&#39;,}// 존재하지 않는 프로퍼티 접근superman.home; // undefined&#39;home&#39; in superman; // false&#39;name&#39; in superman; // true 배열👉 순서가 있는 리스트배열의 특징 문자 뿐만 아니라 숫자, 객체, 함수 등도 모두 포함할 수 있다. length() 메소드는 배열의 길이를 알려준다. 메소드 push(), pop(): 끝요소 추가, 삭제 메소드 unshift(), shift(): 앞요소 추가, 삭제-&amp;gt; 뭔가 unshift가 삭제할 거 같지만, shift가 요소를 삭제한다.마치며이로서 자바스크립트에 대한 개략적인 복습을 했다. 매우 기초적인 내용들이지만 이런 내용들이 싸여서 모두 좋은 밑바탕이 되어 줄거라 생각한다.참고한 영상: https://youtu.be/KF6t61yuPCY코딩앙마 님의 자바스크립트 기초 강좌 : 100분 완성" }, { "title": "(#1) javascript 복습하기 (자료형 ~ 연산자)", "url": "/posts/js-review-1/", "categories": "Web, JavaScript", "tags": "node.js, javascript", "date": "2022-02-09 01:25:30 +0900", "snippet": "서론군 입대 전이랑 군 복무 중에 자바스크립트를 한창 공부했었는데, 또 한동안 공부를 너무 안하다보니 다 까먹게 되어서 전역 후에 한 번 리마인드 시킬 겸 자바스크립트를 빠르게 복습하고자 한다.자료형문자형const name = &quot;justin&quot;; // 문자형const age = &quot;23&quot;;const name1 = &quot;justin&quot;;const name2 = &#39;justin&#39;;const name3 = `justin`;const sentence1 = &quot;I&#39;m a university student.&quot;;const sentence2 = &#39;I\\&#39;m a university student.&#39;;const sentence3 = `I&#39;m ${name}.`;문자형을 선언할 때 총 세 가지 방법이 있다. 쌍따옴표(“”) 따옴표(‘’) 백틱(``)평상시에 문자형 선언 시에는 일반적으로 쌍따옴표를 써주는 게 좋다.따옴표(‘ ‘)는 위의 sentence2처럼 내부에 따옴표를 써야 할 상황에서 앞에 역슬래시(\\)를 적어줘야 하는 불편함이 있다.반면에 백틱(``)은 스트링 내부에 변수를 넣어줘야 하는 경우에 사용하면 유용하다. 내부에 ${} 표기를 통해 쉽게 변수를 삽입할 수 있다.숫자형const num = 1 / 0;// Infinityconst name = &quot;justin&quot;;const div = name / 2;// NaN (= Not a Number)1을 0으로 나누면 무한대 값이 나옴.숫자와 관련된 작업을 할 때 NaN이 나오는지 아닌지 항상 염두에 둘 것.typeof 연산자const name = &quot;justin&quot;;console.log(typeof 4);// &quot;number&quot;console.log(typeof &quot;justin&quot;);// &quot;string&quot;console.log(typeof true);// &quot;boolean&quot;console.log(typeof name);// &quot;string&quot;console.log(typeof null);// &quot;object&quot;console.log(typeof undefined);// &quot;undefined&quot;주의해야 할 점은 null은 object(객체)가 아니라는 점!자바스크립트의 초기 오류라네용 :\\대화상자alert(&quot;안녕하세요&quot;);prompt(&quot;이름을 입력해라&quot;);confirm(&quot;정말 수정하시곘습니까?&quot;);단점 스크립트 일시 정지 (무조건 응답하고 넘어가야 함) 스타일링이 불가능함 (브라우저마다 디자인이 다 다름)—–형변환명시적 형변환String() // 문자형으로 변환Number() // 숫자형으로 변환 Number(&quot;문자&quot;) // NaNBoolean() // 불린형으로 변환 Boolean(0, &quot;&quot;, null, undefined, NaN) // false자동 형변환으로 인해서 파악하기 어려운 오류들이 자주 발생할 수 있기 때문에 명시적 형변환을 통해서 예방해야 한다.주의사항 (그냥 외워)Number(null) // 0Number(undefined) // NaNBoolean(0) // falseBoolean(&#39;0&#39;) // trueBoolean(&#39;&#39;) // falseBoolean(&#39; &#39;) // true연산자비교 연산자const alpha = &quot;1&quot;;const beta = 1;console.log(alpha == beta) // true (동등 연산자)console.log(alpha === beta) // false (일치 연산자)동등 연산자(==)는 type을 신경쓰지 않고 값만을 비교하지만,일치 연산자(===)는 type과 값을 모두 비교해서 불린값을 출력한다.논리 연산자 OR(||)은 첫번째 true를 발견하는 즉시 평가를 멈춘다. AND(&amp;amp;&amp;amp;)는 첫번째 false를 발견하는 즉시 평가를 멈춘다.=&amp;gt; 이를 신경써서 작업하면 성능 최적화에 크게 도움을 줄 수 있다. AND(&amp;amp;&amp;amp;)와 OR(||)이 같이 있으면 AND(&amp;amp;&amp;amp;) 먼저 처리됨.다음 포스팅다음 포스팅은 javascript 함수, 객체, 배열에 대해 복습해보는 시간을 가지게 될 것 같습니다.참고한 영상: https://youtu.be/KF6t61yuPCY코딩앙마 님의 자바스크립트 기초 강좌 : 100분 완성" }, { "title": "마크다운 markdown에 대해서 알아보자", "url": "/posts/about-markdown/", "categories": "GitHub, Pages", "tags": "blog, markdown", "date": "2022-02-05 20:25:30 +0900", "snippet": "마크다운 Markdown1. 마크다운이란? 마크다운(Markdown)은 일반 텍스트 기반의 경량 마크업 언어이다. 마크업 언어란, 태그 등을 이용하여 문서나 데이터의 구조 등을 명기하는 언어의 한 가지이다. 텍스트만으로 서식이 있는 문서들을 작성할 때 자주 사용되며, 다른 마크업 언어들에 비해 문법이 쉽고 간단한 것이 특징. HTML 등의 서식 문서들로 쉽게 변환되기 때문에 README 파일이나 온라인 게시물 등에 사용된다.2. 마크다운의 장단점2-1. 장점- 문법이 간결하고 쉽다.- 거의 대부분의 것에 사용할 수 있다. (웹사이트, 문서, 메모, README 기술파일 등)- 마크다운을 지원하는 플랫폼이 다양하다. (Github, Notion, Discord, Dropbox Paper 등)- 대부분의 환경에서 작성 및 수정이 가능하다. (일반 Notepad에서도 가능)- 텍스트로 저장되어 용량을 많이 차지하지 않는다.- 다양한 형태로 변환이 가능하다.2-2. 단점- 모든 HTML의 마크업을 대신하지 못한다.- 표준이 없기 때문에 툴에 따라 생성물이 다르다.- 마크다운으로 파일을 업로드할 때 저장 이후 파일 경로를 입력해야 한다.3. 마크다운의 문법 다양한 플랫폼에서 사용하는 마크다운이기에 한 번 문법을 알아두면 뽕을 뽑을 수 있다.3-1. Headerh1 ~ h6# 안녕 나는 Header 1야## 안녕 나는 Header 2야### 안녕 나는 Header 3야#### 안녕 나는 Header 4야##### 안녕 나는 Header 5야###### 안녕 나는 Header 6야3-2. StylingEmphasize*Emphasize* or _emphasize_Emphasize or emphasizeString (Bold)**Strong** or __strong__Strong or strongHighlight==Highlight things====Highlight things==하이라이팅은 여기선 안되나 보다. 마크다운의 단점.Cancellation Line~~Cancellation Line~~Cancellation LineQuoted Line&amp;gt; Quoted Line Quoted LineChemical FormulaH~2~O is a liquid.H~2~O is a liquid.Mathematical Formula2^10^ is 1024.2^10^ is 1024.화학식과 수식을 나타내는 문법도 여기선 표현이 안되는 것을 알 수 있다.3-3. List- item * item + item-, *, + 중 어떤 걸로 사용하던 상관없음. item item item - [ ] Incomplete item- [x] Complete item Incomplete item Complete item3-4. Link[NAVER](https://naver.com)Eagle ![Alt](https://images.unsplash.com/photo-1643114673614-55af01ec8dfc?ixlib=rb-1.2.1&amp;amp;ixid=MnwxMjA3fDB8MHx0b3BpYy1mZWVkfDM2fDZzTVZqVExTa2VRfHxlbnwwfHx8fA%3D%3D&amp;amp;auto=format&amp;amp;fit=crop&amp;amp;w=800&amp;amp;q=60)NAVEREagle3-5. CodeSome `inline code`Some inline codeBy using three ₩// using ```var md = &#39;markdown&#39;;By using three ₩ &amp;amp; prog lang// using ```cint main() { printf(&quot;Hello, World&quot;);}3-6. TableItem | Value------ | -----Americano| ₩2500코카콜라 | ₩1200국밥 | ₩6000 Item Value Americano ₩2500 코카콜라 ₩1200 국밥 ₩6000 | Column 1 | Column 2 ||:--------:| -------------:|| centered | right-aligned | Column 1 Column 2 centered right-aligned 3-7. Definition ListHandong University: 경상북도 포항시 북구 흥해읍에 위치한 개신교계 사립 대학교Majors: 전산전자공학부: 기계제어공학부: ICT창업학부 : ETC. Handong University 경상북도 포항시 북구 흥해읍에 위치한 개신교계 사립 대학교 Majors 전산전자공학부 기계제어공학부 ICT창업학부 etc.3-8. FootnoteSome text with a footnote.[^1][^1]: The footnote.Some text with a footnote.[^1][^1]: The footnote.——3-9. AbbreviationMarkdown converts text to HTML.*[HTML]: HyperText Markup LanguageMarkdown converts text to HTML.*[HTML]: HyperText Markup Language——3-10. LaTeX mathThe Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ is via the Euler integral$$\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.$$The Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\foralln\\in\\mathbb N$ is via the Euler integral\\[\\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,.\\]Footnote, Abbreviation, LaTeX math도 적용이 안되는 걸 볼 수 있다.Extra. 줄바꿈마크다운에서는 줄바꿈하는 방법이 좀 생소함.일반 텍스트 문장에서는 문장 끝에 공백 2번(스페이스 2번)하면 줄 바꿈이 됨.예를 들어, 지금 공백 2번 만들어서 지금과 공백 사이에서 줄바꿈이 된다.결과값 :예를 들어, 지금공백 2번 만들어서 지금과 공백 사이에서 줄바꿈이 된다.테이블 내에서나 일반적인 경우.나는 개인적으로 이걸 쓰는 걸 더 좋아함.안녕하세요. &amp;lt;br&amp;gt;줄바꿨어요.결과값 :안녕하세요. 줄바꿨어요.결론markdown은 유용한 툴임에는 틀림 없지만 눈에 띄는 단점 역시 존재한다!" } ]
